{
	"patcher" : 	{
		"fileversion" : 1,
		"appversion" : 		{
			"major" : 8,
			"minor" : 0,
			"revision" : 3,
			"architecture" : "x64",
			"modernui" : 1
		}
,
		"classnamespace" : "dsp.gen",
		"rect" : [ 40.0, 114.0, 1026.0, 440.0 ],
		"bglocked" : 0,
		"openinpresentation" : 0,
		"default_fontsize" : 12.0,
		"default_fontface" : 0,
		"default_fontname" : "Arial",
		"gridonopen" : 1,
		"gridsize" : [ 15.0, 15.0 ],
		"gridsnaponopen" : 1,
		"objectsnaponopen" : 1,
		"statusbarvisible" : 2,
		"toolbarvisible" : 1,
		"lefttoolbarpinned" : 0,
		"toptoolbarpinned" : 0,
		"righttoolbarpinned" : 0,
		"bottomtoolbarpinned" : 0,
		"toolbars_unpinned_last_save" : 0,
		"tallnewobj" : 0,
		"boxanimatetime" : 200,
		"enablehscroll" : 1,
		"enablevscroll" : 1,
		"devicewidth" : 0.0,
		"description" : "",
		"digest" : "",
		"tags" : "",
		"style" : "",
		"subpatcher_template" : "",
		"boxes" : [ 			{
				"box" : 				{
					"id" : "obj-10",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 209.0, 527.0, 150.0, 20.0 ],
					"text" : " recording ramp end"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-7",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 256.33331298828125, 503.0, 35.0, 22.0 ],
					"text" : "out 3"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-8",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 9.0, 516.0, 150.0, 20.0 ],
					"text" : "songStart"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-6",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 11.0, 490.0, 35.0, 22.0 ],
					"text" : "out 2"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-5",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 690.0, 32.0, 84.0, 22.0 ],
					"text" : "buffer clicklog"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-3",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 705.0, 56.0, 113.0, 22.0 ],
					"text" : "buffer incrementlog"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-1",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 807.0, 56.0, 110.0, 22.0 ],
					"text" : "buffer extendedlog"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-34",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 807.0, 29.0, 96.0, 22.0 ],
					"text" : "buffer steadylog"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-19",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 557.333374000000049, 97.0, 30.0, 22.0 ],
					"text" : "in 3"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-32",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 383.5, 535.0, 57.0, 20.0 ],
					"text" : "songEnd"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-30",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 393.5, 508.0, 37.0, 22.0 ],
					"text" : "out 4"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-45",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 545.8333740234375, 539.0, 53.0, 20.0 ],
					"text" : "phasor~"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-55",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 545.8333740234375, 512.0, 37.0, 22.0 ],
					"text" : "out 6"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-24",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 371.0, 100.25, 30.0, 22.0 ],
					"text" : "in 2"
				}

			}
, 			{
				"box" : 				{
					"code" : "require(\"log\");\r\n\r\nBuffer stats(\"stats\");\r\nBuffer beats(\"beats\");\r\nBuffer imported(\"imported\");\r\nBuffer pcf(\"pcf\");\r\nBuffer backing_lock_beat(\"backing_lock_beat\");\r\nBuffer play_ramp(\"play_ramp\");\r\nBuffer loop_points(\"loop_points\");\r\nBuffer comping(\"comping\");\r\nBuffer restart(\"restart\");\r\nBuffer starting_frame(\"starting_frame\");\r\nBuffer song(\"song\");\r\nParam tolerance(9);\r\nParam wake(8000);\r\nParam backing_ms(0);\r\nParam loop(0);\r\nParam lead(0);\r\nHistory base(1);\r\nHistory ramp(1);\r\nHistory rec_ramp(1);\r\nHistory extended(0);\r\nHistory saw(0);\r\nHistory bar(0);\t//starting at 0 now rather than one\r\nHistory check(0);\r\nHistory token(0);\r\nlock = stats.peek(10);\r\n\r\n//Upon lock, start the ramp with a jump accounting for the progression through\r\n//a backing track if present. Not necessary when importing because the ramp\r\n//starts up by default\r\nif(change(lock) == 1) {\t//not sure why but this can't be inside if(lock)\r\n\tclick = stats.peek(6) * stats.peek(7);\r\n    now = stats.peek(0);\t\t\t\t\t\t\t\r\n    starting_frame.poke(now, 0);\t\t\t\t\t//with starting_frame updated, all future\r\n    for(i = 0; i < dim(song); i += 1) {\t\t\t//song beats (imported) can be converted to frames\r\n        if(!song.peek(i)) {\r\n            break;\r\n        }\r\n        song.poke(song.peek(i) * click + now, i);\t//placing them actually in the future\r\n    }\r\n\tout1 = 1;\t//songstart sent directly (currently disabled outside)\r\n\tif(!imported.peek(0)) {\r\n\t\t//calculate length of backing track if present, setting song length to it\r\n\t\tbars = ceil(backing_ms / click);\r\n\t\tstats.poke(bars, 1);\r\n\t\tbacking_progression = in2 * bars;\r\n\t\t//backing_progression is already moving even if ramp is not so it can\r\n\t\t//simply be what jump is set to (the rest of the following equation\r\n\t\t//will be zero if there is a backing track). Likewise, backing_progression\r\n\t\t//will be zero otherwise and all that is calculated is the latency in\r\n\t\t//terms of bars\r\n\t\tjump = (stats.peek(0) - pcf.peek(0)) / click + backing_progression;\r\n\t\tbacking_beat = backing_progression;//starting at 0, shouldn't need: + 1;\r\n\t\tbacking_lock_beat.poke(backing_beat, 0);\r\n\t\tfor(channel = 1; channel <= 16; channel += 1) {\t\r\n\t\t\tbeats.poke(backing_beat, channel, 0);\t//if 1st span only 1 hit long, prior beat\r\n\t\t}\t\t\t\t\t\t\t\t\t\t\t//must be updated with backing_progression\r\n\t\t//out1 = backing_beat;\r\n\t\t//blog(incrementlog, stats.peek(0) - pcf.peek(0));\r\n\t\tblog(incrementlog, click);\r\n\t\tblog(incrementlog, bars);\r\n\t\tblog(incrementlog, backing_progression);\r\n\t\tblog(incrementlog, backing_ms);\r\n\t\tblog(incrementlog, jump);\r\n\t\tbar = floor(jump);// + 1;   //Starting at bar 0: shouldn't need +1\r\n\t\tsaw = jump % 1;\r\n\t\trec_ramp = bar + saw;\t//jump rec_ramp as well(bar and saw necessary anymore?)\r\n\t}\r\n}\r\nif(lock) {\r\n\tbars = stats.peek(1);\t//could be turned into a History if not modified externally (which might happen on import)?EDIT: it is now when the song grows\r\n\tloop_end = loop_points.peek(1) + lead;\r\n\tclick = stats.peek(6) * stats.peek(7);\t//once locked, (6) won't change. could avoid peeking\r\n\tincrement = (1 / (SAMPLERATE * (click / 1000)));\r\n\tif(!in3) {\t\t\t\t//if no manual jump has been specified...\r\n\t\tsaw += increment; \t//verified on sample in question ramp does not increment\t\t\t\t\t\t\t\t\t\t\t\t\t//doesnt' account for <-o in first bar.\r\n\t\tif(saw >= 1) {\t//dividing ramp into saw and bar fixed inexplicable glitch\r\n\t\t\tsaw = 0;\t//where it would stall out at bar 1024\r\n\t\t\tbar += 1;\r\n\t\t}\r\n\t\tramp = saw + bar;\r\n\t}\r\n\telse {\r\n\t\tramp = in3;\t\t\t//make the jump\r\n\t\tbar = floor(in3);\r\n\t\tsaw = in3 % 1;\r\n\t}\r\n\tcomp = comping.peek(0);\t\r\n\tif(delta(floor(ramp))) {\t//upon entering each bar\r\n\t\t//blog(extendedlog, ramp);\t\t\t\t\t\t\t\t\t//based on whether\r\n\t\tif(ramp >= bars || (ramp >= loop_end && comp) || restart.peek(0)) {\t//comping, base &\r\n\t\t\tblog(extendedlog, bars);\t\t\t\t\t\t\t\t//peak of ramp set\r\n\t\t\tramp_base = 0;\t\t\t\t\t\t\t\t\t\t\t//to endpoints of\r\n\t\t\tif(comp) {\t\t\t\t\t\t\t\t\t\t\t\t//loop or song\r\n\t\t\t\tramp_base = loop_points.peek(0) - lead;\r\n\t\t\t}\r\n\t\t\tramp = ramp_base;// - (sampstoms(vectorsize * 2) / click);\t//start ramp a vector early so cues at 1 always trigger\r\n\t\t\tbar = ramp_base;\r\n\t\t\t//blog(incrementlog, saw);\r\n\t\t\textended = 0;\r\n\t\t\tblog(extendedlog, 0);\r\n\t\t\tout2 = 1;\r\n\t\t\tnow = stats.peek(0);\t\t\t\t\t\t\t\r\n\t\t\tstarting_frame.poke(now, 0);\t\t\t\t\t//with starting_frame updated, all future\r\n\t\t\tfor(i = 0; i < dim(song); i += 1) {\t\t\t//song beats can be converted to frames\r\n\t\t\t\tif(!song.peek(i)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tsong.poke(song.peek(i) * click + now, i);\t//placing them actually in the future\r\n\t\t\t}\r\n\t\t\tif(!loop) {\t\t//loop comes back around for a split second before edge~\r\n\t\t\t\tlock = 0;\t//triggers at control rate. The need for this all\r\n\t\t\t}\t\t\t\t//could hypothetically be eliminated with a full gen~ system\r\n\t\t\trestart.poke(0, 0);\r\n\t\t}\r\n\t}\r\n\trecording = stats.peek(9);\r\n\tblog(clicklog, recording);\r\n\tif(recording && !comp) {\t\t\t\t//when recording,\r\n\t\trec_ramp += increment;\t//the write head extends separate from the read head\r\n\t}\r\n\telse {\r\n\t\tif(rec_ramp > ramp) {\t//if the record ramp is about to fall back to its base (loop)\r\n\t\t\tout4 = 1;\t\t\t//let the outside world know\r\n\t\t}\r\n\t\trec_ramp = ramp;\t\t//otherwise it stays snapped to it\r\n\t}\r\n\tstats.poke(rec_ramp, 5);\r\n\tplay_ramp.poke(ramp, 0);\r\n\tout3 = ramp;\r\n}\r\nelse {\t//upon import ramp misses initial note(s). A gen~ seq~   would fix\r\n\tout3 = 1;\t//Default position must be 1 even if 0 is the starting of the song to leave room for envelope attacks\r\n}\r\nif(delta(lock) == -1) {\r\n\tstats.poke(1, 1); //bars = 1\r\n\tstats.poke(0, 6); //clickTrack = 0\r\n\tstats.poke(1, 5); //phasor~ = 1\t//Default position must be 1 even if 0 is the starting of the song to leave room for envelope attacks\r\n\tstats.poke(0, 4); // steady = 0\r\n\tbar = 0;\r\n\tsaw = 0;\r\n\tblog(steadylog, 0.0001);\r\n\t//blog(incrementlog, saw);\r\n\t//blog(incrementlog, bar);\r\n}",
					"fontface" : 0,
					"fontname" : "Lucida Console",
					"fontsize" : 12.0,
					"id" : "obj-28",
					"maxclass" : "codebox",
					"numinlets" : 3,
					"numoutlets" : 4,
					"outlettype" : [ "", "", "", "" ],
					"patching_rect" : [ 4.0, 132.25, 1018.33331298828125, 355.75 ]
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-12",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 4.0, 78.0, 72.0, 22.0 ],
					"text" : "sampstoms"
				}

			}
, 			{
				"box" : 				{
					"code" : "out1 = elapsed;\r\nstats.poke(elapsed / (SAMPLERATE / 1000), 0);\t//most effiecient way to write this?",
					"fontface" : 0,
					"fontname" : "Lucida Console",
					"fontsize" : 12.0,
					"id" : "obj-11",
					"maxclass" : "codebox",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 4.0, 2.0, 570.0, 70.0 ]
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-2",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 210.0, 95.0, 30.0, 22.0 ],
					"text" : "in 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-4",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 4.0, 100.25, 37.0, 22.0 ],
					"text" : "out 1"
				}

			}
 ],
		"lines" : [ 			{
				"patchline" : 				{
					"destination" : [ "obj-12", 0 ],
					"source" : [ "obj-11", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-4", 0 ],
					"source" : [ "obj-12", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-28", 2 ],
					"source" : [ "obj-19", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-28", 0 ],
					"source" : [ "obj-2", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-28", 1 ],
					"source" : [ "obj-24", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-30", 0 ],
					"source" : [ "obj-28", 1 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-55", 0 ],
					"source" : [ "obj-28", 2 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-6", 0 ],
					"source" : [ "obj-28", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-7", 0 ],
					"source" : [ "obj-28", 3 ]
				}

			}
 ],
		"editing_bgcolor" : [ 0.9, 0.9, 0.9, 1.0 ]
	}

}
