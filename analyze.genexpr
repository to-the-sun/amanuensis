tolerate(interval) {
    Buffer rhythm("rhythm");
    Buffer tolerance("tolerance");
    Buffer rhythm_peak("rhythm_peak");
    Buffer rhythm_peaks("rhythm_peaks");
    Buffer rhythm_cursor("rhythm_cursor");
    TOLERANCE = peek(tolerance, 0);
    cursor = peek(rhythm_cursor, 0);
    for(ms = round(interval - TOLERANCE); ms <= interval + TOLERANCE; ms += 1) {
        incremented = peek(rhythm, ms) + 1;
        poke(rhythm, incremented, ms);
        peak = peek(rhythm_peak, 0);
        if(incremented > peak) {
            poke(rhythm_peak, incremented, 0);
            poke(rhythm_peaks, incremented, 0, 0);
            poke(rhythm_peaks, ms, 0, 1);
            cursor = 1;
        }
        else if(incremented == peak) {
            poke(rhythm_peaks, incremented, cursor, 0);
            poke(rhythm_peaks, ms, cursor, 1);
            cursor += 1;
        }
    }
    poke(rhythm_cursor, cursor, 0);
    return interval;
}
analyze(now, source, TOLERANCE, WAKE) {
    Buffer memory("memory");
    Buffer involved_indices("involved_indices");
    Buffer oldest("oldest");
    Buffer past_beats("past_beats");
    Buffer starting_frame("starting_frame");
    Buffer unlocked_start("unlocked_start");
    Buffer scores("scores");
    Buffer scores_cursor("scores_cursor");
    atom = TOLERANCE * 2;
    //Analyze beats
    involvements = 0;
    area = 0;
    score = 0;
    connections = 0;
    click = 0;
    //beats_back = 1;
    oldest_index = peek(oldest, 0);
    beats_back = ((oldest_index - (peek(past_beats, 0) - 2)) + dim(memory)) % dim(memory);  //-1 would give newest filled index (now). -2 to get the next back, 1st to analyze
    past_beat = peek(memory, beats_back, 0);
    while(past_beat) {
        if(peek(memory, beats_back, 2) != source * -1) {    //Cannot score off of its direct competition
            interval = now - past_beat;
            sync = 0;
            if(abs(interval) <= TOLERANCE) { //Success: beats coincide. In theory abs() should be unnecessary as beats should never be out of order
                sync = 1;   //No need to check coinciding: next past_beat will be checked right away anyway
            }
            else if(interval <= WAKE + TOLERANCE) {
                target = past_beat - interval;
                check_index = ((beats_back + 1) + dim(memory)) % dim(memory);
                check = peek(memory, check_index, 0);
                while(check) {
                    if(peek(memory, check_index, 2) != source * -1) {    //Cannot score off of its direct competition
                        proximity = target - check;
                        if(abs(proximity) <= TOLERANCE) {  //Success
                            if(!click) { // Unlikely, but if 2 intervals sync at lock larger would otherwise be conveyed â€“ smaller is ideal
                                click = interval;    //Interval conveyed through click for sake of locking.
                            }
                            sync = 1;
                            poke(involved_indices, check_index, involvements);
                            involvements += 1;
                            area += interval;
                            if(peek(memory, check_index, 2) > 0) {  //If source designates it's recitation
                                connections += 1;
                            }
                            poke(scores, check, peek(scores_cursor, 0));
                            poke(scores_cursor, peek(scores_cursor, 0) + 1, 0);
                            first_hit = peek(unlocked_start, 0);
                            if(!first_hit || check < first_hit) {   //Oldest scoring beat sets song_start pre-lock
                                poke(unlocked_start, check, 0);     //(What if a subsequent pattern reaches further back?
                            }                                       //Cues/span might be placed negative?) YES. Therefore, check < song_start added
                            coinciding_check_index = ((check_index + 1) + dim(memory)) % dim(memory);
                            coinciding_check = peek(memory, coinciding_check_index, 0);
                            while(abs(target - coinciding_check) <= TOLERANCE) {
                                if(peek(memory, coinciding_check_index, 2) != source * -1) {    //Cannot score off of its direct competition
                                    poke(involved_indices, coinciding_check_index, involvements);
                                    involvements += 1;
                                    if(peek(memory, coinciding_check_index, 2) > 0) {  //If source designates it's recitation
                                        connections += 1;
                                    }
                                    poke(scores, coinciding_check, peek(scores_cursor, 0));
                                    poke(scores_cursor, peek(scores_cursor, 0) + 1, 0);
                                    coinciding_check_index = ((coinciding_check_index + 1) + dim(memory)) % dim(memory);
                                    coinciding_check = peek(memory, coinciding_check_index, 0);
                                }
                            }
                            target -= interval;
                        }
                        else if(proximity > TOLERANCE) {    //Overshot
                            break;
                        }
                    }
                    check_index = ((check_index + 1) + dim(memory)) % dim(memory);
                    check = peek(memory, check_index, 0);
                }
            }
            else if(interval > WAKE + TOLERANCE) {  //Overshot
                break;
            }
            if(sync) {
                poke(involved_indices, beats_back + 1, involvements);   //+1 because while() chokes on a 0 index. Accounted for later
                involvements += 2;
                area += interval;
                if(peek(memory, beats_back, 2) > 0) {  //If source designates it's recitation
                    connections += 1;
                }
                /*poke(scores, past_beat, peek(scores_cursor, 0));
                poke(scores, interval, peek(scores_cursor, 0) + 1);
                poke(scores, source, peek(scores_cursor, 0) + 2);
                poke(scores, -69, peek(scores_cursor, 0) + 3);  //Arbitrary delimiter
                poke(scores_cursor, peek(scores_cursor, 0) + 4, 0);*/
            }
            if(source > 0 && source == peek(memory, beats_back, 2)) { //Only recitation intervals on the same source
                tolerate(interval);
            }
        }
        beats_back = ((beats_back + 1) + dim(memory)) % dim(memory);
        past_beat = peek(memory, beats_back, 0);
    }
    //Tally scores for involved beats. Total stats cannot be known until analysis is complete
    if(involvements) {  //Why not just include index 0 as an involvement? Because while() sees index 0 as empty and stops
        song_start = peek(starting_frame, 0);
        score = area;
        poke(memory, peek(memory, 0, 3) + score, 0, 3);
        if(!song_start) {  //Update default song_start to 0 (necessary only when unlocked_start 1st set)
            poke(memory, 0, 0, 5);    //If 0, Crucible will process it using unlocked_start
        }
        scoring_involvement = 0;
        scoring_index = peek(involved_indices, scoring_involvement);
        while(scoring_index) {
            scoring_index -= 1;                     //Decrement the false increment
            poke(memory, now, scoring_index, 1);
            poke(memory, peek(memory, scoring_index, 3) + score, scoring_index, 3);
            if(!song_start) {  //Update default song_start to 0 (necessary only when unlocked_start 1st set)
                poke(memory, 0, scoring_index, 5);    //If 0, Crucible will process it using unlocked_start
            }
            poke(involved_indices, 0, scoring_involvement);
            scoring_involvement += 1;
            scoring_index = peek(involved_indices, scoring_involvement);
        }
    }
    return click, score, beats_back, oldest_index;
}